// Generated by CoffeeScript 1.8.0
(function() {
  var Dao, connect, dao, pg, _;

  _ = require('lodash');

  pg = require('pg');

  connect = function(o, cb) {
    return pg.connect(o.dbUrl, function(err, client, done) {
      if (err) {
        err = {
          type: 'DAOBASE_SQL_CONNECT_ERROR',
          err: err
        };
        return cb(err);
      }
      o._client = client;
      o._done = function() {
        o._client = void 0;
        return done();
      };
      return cb(null);
    });
  };

  dao = {};

  Dao = function(dbUrl) {
    _.assign(this, dao);
    return this.dbUrl = dbUrl;
  };

  dao.sqlOp = function(sql, cb) {
    var self;
    self = this;
    if (!_.isArray(sql)) {
      sql = [sql];
    }
    sql.push(function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_GENERIC_SQL_ERROR',
          err: err,
          query: sql
        };
        self._done(err);
        return cb(err);
      }
      return cb(null, result);
    });
    if (!this._client) {
      return connect(this, function(err, result) {
        if (err) {
          return cb(err);
        }
        return self.sqlOp(sql, function(err, result) {
          if (err) {
            return cb(err);
          }
          self._done();
          return cb(null, result);
        });
      });
    } else {
      return this._client.query.apply(this._client, sql);
    }
  };

  dao.commit = function(cb) {
    var self;
    self = this;
    return this.sqlOp('COMMIT', function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_COMMIT_ERROR',
          err: err
        };
        return cb(err);
      }
      self._done();
      return cb();
    });
  };

  dao.get = function(data, cb) {
    var err, f, query, sql;
    if (!((data != null) && data.table && data.fields && data.values)) {
      err = {
        type: 'DAOBASE_GET_INVALID_REQUEST',
        data: data
      };
      return cb(err);
    }
    if (!(_.isArray(data.fields))) {
      data.fields = [data.fields];
      data.values = [data.values];
    }
    query = 'SELECT * FROM ' + data.table + ' WHERE ' + ((function() {
      var _i, _j, _len, _ref, _ref1, _results, _results1;
      _ref1 = _.zip(data.fields, (function() {
        _results1 = [];
        for (var _j = 1, _ref = data.values.length; 1 <= _ref ? _j <= _ref : _j >= _ref; 1 <= _ref ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this));
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        f = _ref1[_i];
        _results.push(f[0] + '=$' + f[1]);
      }
      return _results;
    })()).join(' AND ');
    sql = [query, data.values];
    return this.sqlOp(sql, function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_GET_ERROR',
          err: err
        };
        return cb(err);
      }
      if (result.rows.length < 1) {
        err = {
          type: 'DAOBASE_GET_NO_MATCH',
          data: data
        };
        return cb(err);
      }
      if (result.rows.length > 1) {
        err = {
          type: 'DAOBASE_GET_MULTIPLE_MATCHES',
          data: data
        };
        return cb(err);
      }
      return cb(null, result.rows[0]);
    });
  };

  dao.insert = function(data, cb) {
    var err, field, i, query;
    if (!((data != null) && data.table && data.values)) {
      err = {
        type: 'DAOBASE_INSERT_INVALID_REQUEST',
        data: data
      };
      return cb(err);
    }
    if (!_.isArray(data.values)) {
      data.values = [data.values];
      if (!(data.fields == null)) {
        data.fields = [data.fields];
      }
    }
    query = 'INSERT INTO ' + data.table + ' ';
    if (!(data.fields == null)) {
      query += '(' + ((function() {
        var _i, _len, _ref, _results;
        _ref = data.fields;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          _results.push(field);
        }
        return _results;
      })()) + ') ';
    }
    query += 'VALUES (' + ((function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = data.values.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push('$' + i);
      }
      return _results;
    })()) + ')';
    if (!(data.returning == null)) {
      query += ' RETURNING ' + data.returning;
    }
    return this.sqlOp([query, data.values], function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_INSERT_ERROR',
          err: err,
          data: data
        };
        return cb(err);
      }
      result = data.returning ? result.rows[0][data.returning] : true;
      return cb(null, result);
    });
  };

  dao.update = function(data, cb) {
    var err, f, nSel, nUpd, query, sql;
    if (!((data != null) && data.table && data.updFields && data.updValues && data.selFields && data.selValues)) {
      err = {
        type: 'DAOBASE_UPDATE_INVALID_REQUEST',
        data: data
      };
      return cb(err);
    }
    if (!_.isArray(data.updFields)) {
      data.updFields = [data.updFields];
      data.updValues = [data.updValues];
    }
    if (!_.isArray(data.selFields)) {
      data.selFields = [data.selFields];
      data.selValues = [data.selValues];
    }
    nUpd = data.updValues.length;
    nSel = data.selValues.length;
    sql = 'UPDATE ' + data.table + ' SET ' + (((function() {
      var _i, _j, _len, _ref, _results, _results1;
      _ref = _.zip(data.updFields, (function() {
        _results1 = [];
        for (var _j = 1; 1 <= nUpd ? _j <= nUpd : _j >= nUpd; 1 <= nUpd ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this));
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push(f[0] + '=$' + f[1]);
      }
      return _results;
    })()).join(',')) + ' WHERE ' + ((function() {
      var _i, _j, _len, _ref, _ref1, _ref2, _results, _results1;
      _ref2 = _.zip(data.selFields, (function() {
        _results1 = [];
        for (var _j = _ref = nUpd + 1, _ref1 = nUpd + nSel; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; _ref <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this));
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        f = _ref2[_i];
        _results.push(f[0] + '=$' + f[1]);
      }
      return _results;
    })()).join(' AND ');
    query = [sql, data.updValues.concat(data.selValues)];
    return this.sqlOp(query, function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_UPDATE_ERROR',
          err: err,
          data: data
        };
        return cb(err);
      }
      return cb(null, result.rowCount);
    });
  };

  dao["delete"] = function(data, cb) {
    var err, f, sql;
    if (!((data != null) && data.table && data.fields && data.values)) {
      err = {
        type: 'DAOBASE_DELETE_INVALID_REQUEST',
        data: data
      };
      return cb(err);
    }
    if (!_.isArray(data.fields)) {
      data.fields = [data.fields];
      data.values = [data.values];
    }
    sql = 'DELETE FROM ' + data.table + ' WHERE ' + ((function() {
      var _i, _j, _len, _ref, _ref1, _results, _results1;
      _ref1 = _.zip(data.fields, (function() {
        _results1 = [];
        for (var _j = 1, _ref = data.fields.length; 1 <= _ref ? _j <= _ref : _j >= _ref; 1 <= _ref ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this));
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        f = _ref1[_i];
        _results.push(f[0] + '=$' + f[1]);
      }
      return _results;
    })()).join(' AND ');
    return this.sqlOp([sql, data.values], function(err, result) {
      if (err) {
        err = {
          type: 'DAOBASE_DELETE_ERROR',
          err: err,
          data: data
        };
        return cb(err);
      }
      if (result.rowCount < 1) {
        err = {
          type: 'DAOBASE_DELETE_NO_MATCH',
          data: data
        };
        return cb(err);
      }
      return cb(null, result.rowCount);
    });
  };

  dao.tx = function(cb) {
    var d;
    d = new Dao();
    d.dbUrl = this.dbUrl;
    return connect(d, function(err) {
      if (err) {
        return cb(err);
      }
      return d.sqlOp('BEGIN', function(err) {
        if (err) {
          err = {
            type: 'DAOBASE_BEGIN_ERROR',
            err: err
          };
          return cb(err);
        }
        return cb(null, d);
      });
    });
  };

  module.exports = Dao;

}).call(this);
